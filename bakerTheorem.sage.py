

# This file was *autogenerated* from the file bakerTheorem.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_3 = Integer(3); _sage_const_10 = Integer(10)
def flatten_list(nested_list):
    return [item for sublist in nested_list for item in sublist]


# SageMath에서 변수를 정의합니다.
var('x, b, L, n, h')

L = _sage_const_2 
n = _sage_const_2 
h = _sage_const_2 
D = _sage_const_1 
c = matrix(L+_sage_const_1 , L+_sage_const_1 , [var("c_{}{}".format(i,j),latex_name="c_{{{}{}}}".format(i,j)) for i in (ellipsis_range(_sage_const_0 ,Ellipsis,L)) for j in (ellipsis_range(_sage_const_0 ,Ellipsis,L))])

print("(h+1)*(D+1)^(n-1) < (L+1)^n : ", (h+_sage_const_1 )*(D+_sage_const_1 )**(n-_sage_const_1 ) < (L+_sage_const_1 )**n)
print("------------------------------------------------------------------------------------------------------------------------------------------------------------------------")

# 주어진 함수를 정의합니다.
f = sum(sum(c[s,t]*_sage_const_3 **(s*x)*_sage_const_2 **(t*x) for s in range(L+_sage_const_1 )) for t in range(L+_sage_const_1 ))

# 함수 f에서 가장 윗 계수 c[L,L]을 -1로 대체합니다.
f = f.subs(c[L,L] == -_sage_const_1 )

# 함수를 x에 대해 D번까지 미분합니다.
df = [f.diff(x, i) for i in range(D+_sage_const_1 )]

# 미분한 결과를 출력합니다.
print(latex(df))
print("-----------------------------------------------------------------------------------------------------------------------------------------------------------------------")


# log(3)을 b*log(2)로 대체합니다. (log(3)^3을 b^3**log(2)^3 로 문제없이 잘 대체합니다.)
dfb = [d.subs(log(_sage_const_3 ) == b*log(_sage_const_2 )) for d in df]

# 결과를 출력합니다.
print(latex(dfb))
print("------------------------------------------------------------------------------------------------------------------------------------------------------------------------")


# b에 대한 항과 그렇지 않은 항을 분리합니다.
dfb_b_terms = [d.coefficients(b) for d in dfb]

# 결과를 출력합니다.
# print(latex(dfb_b_terms))
# print("------------------------------------------------------------------------------------------------------------------------------------------------------------------------")
# 각 계수를 별도의 함수로 정의합니다.
cf = [[(term[_sage_const_0 ]/log(_sage_const_2 )**m).simplify_full().expand() for term in terms] for m,terms in enumerate(dfb_b_terms)]

print("number of equations: ", len(flatten_list(cf))*(h+_sage_const_1 ))
print("number of variables: ", (L+_sage_const_1 )**n)
print("------------------------------------------------------------------------------------------------------------------------------------------------------------------------")
# 결과를 출력합니다.

# print(latex(cf))
# print("------------------------------------------------------------------------------------------------------------------------------------------------------------------------")
# 
# print(latex(c))
# print("------------------------------------------------------------------------------------------------------------------------------------------------------------------------")

# f_b=[]
# 각 함수를 출력합니다.
# for i, fi in enumerate(cf):
    # f_b.append((fi/log(2)^m).simplify_full().expand())#[m.expand() for m in .operands()]
    # print(f"f_b^{i}(x) = {[m.expand() for m in (fi/log(2)).simplify_full().expand().operands()]}")
    # for j in range(h+1):
        # print(f_b[i](x=j))#[g(x=j) for g in ])


# 방정식 시스템을 정의합니다.
eqs = [[[cf[i][j](x=l) == _sage_const_0  for l in range(h+_sage_const_1 )] for j in range(i+_sage_const_1 )] for i in range(D+_sage_const_1 )]
eqs_flat = flatten_list(flatten_list(eqs))

# 결과를 출력합니다.
# print(eqs)
# print("------------------------------------------------------------------------------------------------------------------------------------------------------------------------")
# print(latex(eqs_flat))
# print("------------------------------------------------------------------------------------------------------------------------------------------------------------------------")

def linear_equations_to_matrix(eqns,c):
    return (matrix([[eq.lhs().coefficient(v) for v in c] for eq in eqns])
    ,c)
# from sage.symbolic.relation import linear_equations_to_matrix

# A, b = linear_equations_to_matrix(eqs_flat, flatten_list(c))

# Now, 'A' is the coefficient matrix and 'b' is the constant vector

# print("Coefficient matrix, A:")
# print(latex(A))
# print("Constant vector, b:")
# print(latex(b))
# print("------------------------------------------------------------------------------------------------------------------------------------------------------------------------")

# 방정식 시스템을 풉니다.
solution = solve(eqs_flat, flatten_list(c), solution_dict=True)

# 해를 출력합니다.
print(latex(solution))
print("------------------------------------------------------------------------------------------------------------------------------------------------------------------------")

df_sol = [d.subs(solution) for d in df]
print(latex(df_sol))
print("------------------------------------------------------------------------------------------------------------------------------------------------------------------------")


plot(df_sol[_sage_const_0 ](x=x),(x,-_sage_const_10 ,_sage_const_10 ))
# 각 항을 분배 법칙에 따라 재구성합니다.
# dfb_expanded = dfb.expand()

# 재구성된 식을 출력합니다.
# print(dfb_b_terms)
# print("------------------------------------------------------------------------------------------------------------------------------------------------------------------------")
# 미분한 결과를 출력합니다.
# print(dfb)
# print("------------------------------------------------------------------------------------------------------------------------------------------------------------------------")
# print(f)
# print("------------------------------------------------------------------------------------------------------------------------------------------------------------------------")
# print(latex(dfb))
# print(latex(dfb))
# print(latex(f))

